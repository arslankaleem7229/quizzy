import { Worker, Job } from "bullmq";
import Redis from "ioredis";
import prisma from "@/prisma/client";
import { QuestionType, JobStatus, Prisma } from "@/app/generated/prisma";
import { quizWithLocalizationInclude } from "@/lib/types/api";
import { callOpenAI, slugify } from "@/lib/ai/openai";
import type { Server } from "socket.io";
import { GenAIJobData } from "@/lib/queue";
import { normalizeOptions } from "@/app/api/quizz/options.helper";

declare global {
  var io: Server | undefined;
}

const connection = new Redis({
  host: process.env.REDIS_HOST || "localhost",
  port: parseInt(process.env.REDIS_PORT || "6379"),
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: null,
});

connection.on("connect", () => {
  console.log("[Worker] Redis connected");
});

connection.on("error", (err) => {
  console.error("[Worker] Redis error:", err);
});

export const aiWorker = new Worker<GenAIJobData>(
  "quizz-generation",
  async (job: Job<GenAIJobData>) => {
    const { jobId, userId, title, description, language, inputText } = job.data;

    console.log(`[Worker] Processing job ${jobId}`);
    console.log(`User: ${userId}`);
    console.log(`Attempt: ${job.attemptsMade + 1}/${job.opts.attempts}`);

    try {
      await prisma.genAIJob.update({
        where: { id: jobId },
        data: {
          status: JobStatus.PROCESSING,
          startedAt: new Date(),
        },
      });
      if (global.io) {
        console.log("HITTING TO GLOBAL IO");
        global.io.to(`user:${userId}`).emit("job-update", {
          jobId,
          status: "processing",
          message: "Generating your quiz...",
        });
      } else {
        console.log("FUCKed");
      }

      console.log(`Calling AI API...`);
      const startTime = Date.now();

      const aiQuiz = await callOpenAI(inputText || "", language);

      const duration = Date.now() - startTime;
      console.log(`AI completed in ${duration}ms`);

      const questions = aiQuiz.questions.map((question) => ({
        ...question,
        questionType: question.questionType ?? QuestionType.SINGLE_CHOICE,
      }));

      const optionsByQuestion = questions.map((question) =>
        normalizeOptions(question, [])
      );

      console.log(`Saving quiz to database...`);
      const quiz = await prisma.quiz.create({
        data: {
          slug: slugify(aiQuiz.title || title || "quiz"),
          createdById: userId,
          isPublished: true,
          totalQuestions: questions.length,
          localizations: {
            create: [
              {
                language: aiQuiz.language || language || "en",
                title: aiQuiz.title || title || "AI Quiz",
                description:
                  aiQuiz.description || description || "Generated by AI",
                questionCount: questions.length,
                questions: {
                  create: questions.map((question, index) => {
                    const options = optionsByQuestion[index];
                    return {
                      questionText: question.term,
                      questionType: question.questionType,
                      explanation: question.explanation ?? "",
                      hint: question.hint ?? "",
                      points: 1,
                      orderIndex: index,
                      difficultyLevel: 1,
                      hasAttachment: false,
                      options: {
                        create: options.map((opt, optIndex) => ({
                          optionText: opt.optionText,
                          isCorrect: opt.isCorrect,
                          orderIndex: opt.orderIndex ?? optIndex,
                          hasAttachment: false,
                        })),
                      },
                    };
                  }),
                },
              },
            ],
          },
        },
        include: quizWithLocalizationInclude,
      });

      console.log(`Quiz created: ${quiz.id}`);

      await prisma.genAIJob.update({
        where: { id: jobId },
        data: {
          status: JobStatus.COMPLETED,
          quizId: quiz.id,
          aiResponse: aiQuiz as Prisma.InputJsonValue,
          completedAt: new Date(),
        },
      });

      if (global.io) {
        global.io.to(`user:${userId}`).emit("job-update", {
          jobId,
          status: "completed",
          message: "Quiz ready!",
          quizId: quiz.id,
          quiz: quiz,
        });
      }

      console.log(`Job ${jobId} completed successfully`);

      return { success: true, quizId: quiz.id };
    } catch (error) {
      console.error(`Job ${jobId} failed:`, error);

      await prisma.genAIJob.update({
        where: { id: jobId },
        data: {
          status: JobStatus.FAILED,
          errorMessage: error?.toString(),
          completedAt: new Date(),
          retryCount: {
            increment: 1,
          },
        },
      });
      if (global.io) {
        global.io.to(`user:${userId}`).emit("job-update", {
          jobId,
          status: "failed",
          message: "Failed to generate quiz",
          error: error?.toString(),
        });
      }

      throw error;
    }
  },
  {
    connection,
    concurrency: 5,
    limiter: {
      max: 10,
      duration: 1000,
    },
  }
);

aiWorker.on("completed", (job) => {
  console.log(`[Worker] Job ${job.id} completed`);
});

aiWorker.on("failed", (job, err) => {
  console.log(`[Worker] Job ${job?.id} failed:`, err.message);
});

aiWorker.on("error", (err) => {
  console.error("[Worker] Worker error:", err);
});

console.log("[Worker] AI generation worker started");
console.log("[Queue]: ai-generation");
console.log("Concurrency: 5 jobs");
